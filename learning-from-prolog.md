1. A totally different way of looking at programming

IO helped me see how JS worked but more deeply understand how Ruby, PhP and other languages implemented OO. By adding a contrast. 

It also made me think alot about metaprogramming and how to manipulate the underlying code I work. 


2. It's made me appreciate more what SQL is about

SQL is another declarative language. It explains why doing alot of imperative coding in SQL is so weird. Its bolted on. SQL was always about give me a request and I will fulfill it. Don't tell me what to do. 

You might plan how to phrase a request in SQL to help it optimise. But more and more that's SQL's job too. 

It makes the language feel almost fake and mysterious compared to Ruby or PhP.


3. It's excited me about logic

It's intriguing to see a different approach.

I think it's made me more open to understanding the funcational paradigm. I've been working solely with imperative languages (other than SQL, but even then I often do it with an ORM). And so it's made me think. 

It's often alot like learning history, the more you learn, the more you realise you can't take anything for granted. The more distinct and different a society you study, the more you see the base assumptions you've been making but are totally unaware of. 

So for imperative, well obviously I should have how my code is working figured out. 
Instead with Prolog it's about thinking about the rules, its almost a bit reverse TDD - you make the rules and then the programme will answer the questions. In TDD you write the tests (aka the rules) and then you have to figure out how it should work. 

You can see how it can produce some quite novel solutions and ideas from basic logic. 

5. It's helped me understand recursion more

Alot of the challenges have involved recursion. And its forced me to practise building up a recursive function.
But particularly, I've found it quite a helpful approach - writing the rules out. Slowly building up a pattern to find the base case and then to find the recusion. 
It's alot easier in the long run with prolog because you can't just write it as a loop first. And because it's focused on the rules not actually the proccess it forces you to clarify your thinking alot more. 
rewind([Value], [Value]).

In many ways I find the declarative way of defining recursion in some ways simpler. It's going back to first principals. But it is harder too.
Also not being able to alter variables is highly alein to me - but I hope will set me up well for haskel etc.

But also the declarative way of defining recursive rules helps you understand how you build those recursive results. 

I've also always been less of a fan of recursion - looping makes alot more intuative sense to me. But I can see why recursion is in some ways more expressive. As in many ways, its how we probably instinctively approach some problems.

6. It's a really useful skill to hone

It's pushing me to think less and less about implementation first. But instead, defining the problem, working out the rules and facts. It's really quite good for getting you to go back to first principals.

7. Learning theory - do before understanding

One thing with prolog is that it's approach is so different to anything I've done before.
But also, I've found the classic example - sometimes implementing things we don't udnerstand is fine. 

There's a bit of a debate about this in teaching - some teachers believe in gettikng students to be able to do things, before they can understand. Arguing udnerstanding takes time, and the more you do something the more you can start to understand it. Rather than spending ages trying to understand something before doing it. 

And I've found that a useful approach with prolog. I've implemented some challenges, and kind of got them, but also known how to do them. 
But the more you do, the more you spot the patterns and understand why you do it that way.

It's a bit the same for the anki cards I'm using. They are facts that I do understand but don't fully get. But repeating them daily gives me time to focus on them, in different contexts. And it enables me to see different connections. 

The main thing I learn more and more as I code - is everything is essentially just words. You can manipulate change then, you can do what you want. YOu just need to know how.
