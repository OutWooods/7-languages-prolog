# Doing before understanding

Often there is a bit of feeling in education that you should understand everything you do. 

This makes sense too - there's been a big reaction against 'process' driven learning, especially in maths. By which I mean, you learn how to solve problems, you learn the steps, but you never get taught why. You just get taught that's how you do it. 

The big opposite movement is a real focus on indepth teaching, with lots of focus for understanding, experimentation. This has often led to a teaching style called 'discover-learning' where instead of being told processes, students are given problems designed for them to gradually develop rules from first principals. So students will in the end use the processes, but they will have developed them, and they understand 'why' they work. Not just how they work. 

Often alot of coding courses feel like one or the other approach. Either it's literally just super simple steps 'type this in' and then it works, or its the whole philosophy 'pick a project' and then do the project. You'll discover the rules along the way. 

oThe key thing the research suggests is you need a bit of both. Learning processes without understanding is bad - you struggle to retain the information anyway, but also you can't apply it to novel solutions. But discovery learning, where you have a project, often leads to chaos - you don't know where to look, what's going wrong, you can spend 3 hours and know nothing more except that your evening is gone. This is because whilst discovery sounds great, newbies struggle to spot what they're meant to be looking for - they make up rules that you wouldn't expect because they don't have the base knowledge. On top of this, they can end up reinforcing this wrong idea over and over again, so it makes it really hard to undo. Aka not only has that 3 hours been wasted, but they've actually decreased there understanding.

Now a typical response to this is - well I'll just explain to people why they're doing something and then how to do it. Aka direct instruction. An expert teachers how and why. And that is true. But this falls into a new trap - cognitive overload. Giving too much information at one time overloads beginners minds, and they struggle to retain or understand any information. 

So what can you do?!

## Inflexible vs flexible knowledge

For newbies, generally its good to get them learning processes, even without understanding. This feels weird at first, but actually alot of learning does not start from understanding - but leads to understanding. Think of all the aha moments when you learn to code - you didn't quite get it, but with more and more use, someday you face a problem that makes everything click.

The key is how the practise is structured, but also later on doing an explanation. 

When you first learn a process its pretty inflexible knowledge. You can only apply it to certain contexts, its very rigid and fixed. But as you use and apply it more to different contexts, you'll start to see what works and what doesn't. The knowledge is becoming more flexible. 

The mistake is to suggest the first stage, when you just know a basic process, is not valuable at all. Its how all learning starts - with some very basic ideas that are quite weak. Good instruction, introduces new contexts, new edge cases, new scenarios, gradually. But then also once the process is there, explains HOW it works. This is because, now students know a bit about the process, they've had some experience, they can link your explanation to the experience. The process, the doing of questions, is quite a specific idea, the explanation can be quite high level and theoretical, so it needs something quite specific to cling on to. 

This has the added benefit


## So how does this fit with Prolog

*Disclaimer* rules are hard to follow and I never did this rigidly. When on day three I wanted to solve the sudoku problem, I spent ages trying to solve the question, I never broke it down, looked at solutions (or parts of solutions) and didn't give myself breaks. I should have done all that, but it's hard to follow all the rules. So do give yourself a break if you don't follow my tips.

So all these points about teaching, can be hard to do when learning alone. But the main takeaway, is that doing your own project is not necessarily a good starting point. Instead, finding some curriculum structure is a better idea as a beginner (e.g. 7 languages) you can still apply these principals. With prolog when I got stuck on bits in 7 days, I looked for other courses, and did them (a few uni's have more broken down steps of prolog than the book.)

But beyond that, it changed my mindset and approach to doing problems:

I often looked for example solutions to problems, and then adapted them for different questions. 
ALot of the time, I just had to accept I didn't fully understand. But I could do it. 
I then did a few more questions. Tried subtly different variations. 
Copied some code of the internet, played about with it. 
Then, sought out explanations. 

Another thing I did was have a quick skim of the next day of the book. I often didn't get it, but it meant that when I started tomorrow, I was slightly more familiar with it. (I would also sometimes have a quick go at some of the questions - though I didn't get them right, this would help me start to see gaps in my knowledge.) 

## Top tips for learning

1. You don't need to understand everything - in fact you should expect not to. 
2. Do get into coding quickly, do copy answers, but play about with them. Change them little by little. 
3. Once you can vaguely do a process, then research it a bit. Then do it a bit more. Then do some research. 
4. Sometimes even if you don't fully get it, memorise some definitions, make some anki cards for what predicates are. Over time, these ideas do make more sense, just by having to remember them each and every day. 
5. Spread it out over a few days. If you're really stuck, come back tomorrow. Periods away from a topic often improve problem solving. YOu could well be overloading your mind with new information so it's going to struggle to 
6. Skim through notes for a lesson you plan on doing tomorrow - even do a few questions (this is also called the pre-testing effect. It's well documentated and supported).

Note: If you are an experienced programmer and confident. Then discovery learning will work more for you. You need different approaches for different knowledge levels. Discovery learning works better and better with more and more expert learners. If you think about it, doing a PhD is essentially discovery learning - trial and error. 

One of the most comforting but valuable aspects of this is. If you feel like you don't get it - that's totally OK. In fact, most programmers are doing lots of things they don't fully get. But practise will still help. 

